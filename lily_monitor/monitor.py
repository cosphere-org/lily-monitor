
import os
import textwrap
from datetime import datetime

import requests
from websocket import WebSocket, WebSocketException


# -- @sowj we must figure out a way of injecting required
# -- credentials into autogenerated tests, for know hard-coded
# -- env variables are good enough.
BASE_API_URI = os.environ['BASE_API_URI']

BASE_WS_API_URI = os.environ['BASE_WS_API_URI']

ADMIN_EMAIL = os.environ['ADMIN_EMAIL']

ADMIN_PASSWORD = os.environ['ADMIN_PASSWORD']

FREE_EMAIL = os.environ['FREE_EMAIL']

FREE_PASSWORD = os.environ['FREE_PASSWORD']

LEARNER_EMAIL = os.environ['LEARNER_EMAIL']

LEARNER_PASSWORD = os.environ['LEARNER_PASSWORD']

MENTOR_EMAIL = os.environ['MENTOR_EMAIL']

MENTOR_PASSWORD = os.environ['MENTOR_PASSWORD']

PARTNER_EMAIL = os.environ['PARTNER_EMAIL']

PARTNER_PASSWORD = os.environ['PARTNER_PASSWORD']


class Monitor:

    def __init__(self):
        self.report = []

    def append_to_report(self, method):
        self.entry = {
            'name': f'{self.__class__.__name__}::{method.__name__}',
            'assertions': [],
        }
        self.report.append(self.entry)

    def stop_report(self):
        self.send_to_slack(self.create_report())

    def create_report(self):
        date = datetime.utcnow().strftime('%d-%m-%Y %H:%M')
        header = f'==================== {date} UTC ===================='
        global_success = True

        formatted_report = f'{header}\n'
        for entry in self.report:

            # -- assertions
            assertions_formatted = ''
            all_success = True
            for assertion in entry['assertions']:
                success = assertion['success']
                name = assertion['name']
                expected = assertion.get('expected')
                result = assertion.get('result')
                mark = (success and ':heavy_check_mark:') or ':x:'

                assertions_formatted += f'{mark} {name}'
                if expected and result:
                    assertions_formatted += (
                        f' - *expected* {expected}, *result* {result}\n')

                if not success:
                    all_success = False
                    global_success = False

            success_msg = (all_success and 'SUCCESS') or 'FAILURE'

            assertions_formatted = textwrap.indent(
                assertions_formatted, 5 * '    ').strip()
            formatted_report += textwrap.dedent(f'''
                [{success_msg}] {entry['name']}
                    {assertions_formatted}
            ''')

        if not global_success:
            formatted_report = f'\n <!channel> \n{formatted_report}'

        return formatted_report

    def send_to_slack(self, message):
        # -- @sowj for now we do NOT send to slack when running rendered
        # -- tests locally, when deployed to some virtual machine notifications
        # -- to slack would be the primary pinging mechanism
        print('SEND TO SLACK', {'text': message})
        # requests.post(
        #     SLACK_HOOK_URI, json={'text': message})

    def get_url(self, path):
        return f'{BASE_API_URI}{path}'

    def get_authorization(self):

        response = requests.post(
            self.get_url('/auth/auth_tokens/'),
            json={
                'email': LEARNER_EMAIL,
                'password': LEARNER_PASSWORD,
            })

        assert response.status_code == 201

        token = response.json()['token']
        return {'Authorization': f'Bearer {token}'}

    def assert_duration(self, response, expected_duration):

        try:
            assert response.elapsed.total_seconds() < expected_duration / 1000

        except AssertionError:
            success = False

        else:
            success = True

        finally:
            self.entry['assertions'].append({
                'name': 'test duration',
                'success': success,
                'result': round(response.elapsed.total_seconds() * 1000),
                'expected': expected_duration,
            })

    def assert_status_code(self, response, expected_status_code):

        try:
            assert response.status_code == expected_status_code

        except AssertionError:
            success = False

        else:
            success = True

        finally:
            self.entry['assertions'].append({
                'name': 'test status code',
                'success': success,
                'result': response.status_code,
                'expected': expected_status_code,
            })

    def assert_can_connect_websockets(self, ws_uri):

        try:
            ws = WebSocket()
            ws.connect(ws_uri)

        except WebSocketException:
            success = False

        else:
            success = True

        finally:
            self.entry['assertions'].append({
                'name': 'test can connect to websockets',
                'success': success,
            })
